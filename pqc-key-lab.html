<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <title>PQC Key Lab ‚Äî SLH-DSA + ML-KEM (RFC 9580 / draft-pqc-openpgp)</title>
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <style>
	body {
	  font-family: system-ui, sans-serif;
	  background: #f5f7fa;
	  color: #2c3e50;
	  margin: 0;
	  padding: 1rem;
	}
	.container { max-width: 720px; margin: auto; }
	h1, h2 { color: #1a5f7a; }
	.panel {
	  background: white;
	  border-radius: 8px;
	  padding: 1.5rem;
	  box-shadow: 0 2px 6px rgba(0,0,0,0.05);
	  margin-top: 1rem;
	}
	label { display: block; font-weight: bold; margin-top: 1rem; }
	select, input[type="text"] {
	  width: 100%; padding: 8px; margin-top: 0.5rem;
	  border-radius: 4px; border: 1px solid #ccc;
	}
	.btn-row { display: flex; gap: 0.5rem; margin-top: 1rem; }
	button {
	  padding: 0.65rem 1.2rem;
	  border-radius: 4px; border: none; cursor: pointer;
	  font-weight: bold;
	}
	.btn-primary { background: #1a5f7a; color: white; flex: 2; }
	.btn-secondary { background: #e0ecf1; color: #333; flex: 1; }
	button:hover { opacity: 0.95; }
	.warn-box {
	  background: #fff3cd;
	  border-left: 4px solid #ffc107;
	  padding: 0.75rem; margin-top: 1rem; border-radius: 4px;
	}
	textarea {
	  width: 100%; height: 250px; margin-top: 1rem;
	  font-family: monospace; padding: 0.5rem;
	}
	#output { background: #fafafa; white-space: pre-wrap; word-break: break-all; }
  </style>

  <!-- Load noble libraries via esm.sh as an ES module (correct approach for browser) -->
  <script type="module">
	import { ml_kem768, ml_kem1024 } from ‚Äòhttps://esm.sh/@noble/post-quantum/ml-kem‚Äô;
	import { slh_dsa_shake_256s } from ‚Äòhttps://esm.sh/@noble/post-quantum/slh-dsa‚Äô;
	import { x25519 } from ‚Äòhttps://esm.sh/@noble/curves/x25519‚Äô;
	import { x448 } from ‚Äòhttps://esm.sh/@noble/curves/x448‚Äô;
	import { sha256 } from ‚Äòhttps://esm.sh/@noble/hashes/sha2‚Äô;
	import { hkdf } from ‚Äòhttps://esm.sh/@noble/hashes/hkdf‚Äô;

	// === Helper: Uint8Array ‚Üí correct Base64 ===
	function uint8ToBase64(bytes) {
	  let binary = ‚Äò‚Äô;
	  for (let i = 0; i < bytes.length; i++) binary += String.fromCharCode(bytes[i]);
	  return btoa(binary);
	}

	// === Helper: ASCII-armored OpenPGP block ===
	function armoredOpenPGP(blockType, bytes) {
	  const b64 = uint8ToBase64(bytes).replace(/.{1,76}/g, ‚Äò$&\n‚Äô);
	  return `-----BEGIN PGP ${blockType} KEY BLOCK-----\n\n${b64}-----END PGP ${blockType} KEY BLOCK-----`;
	}

	function hexToBytes(hex) {
	  const bytes = new Uint8Array(hex.length / 2);
	  for (let i = 0; i < bytes.length; i++) bytes[i] = parseInt(hex.substr(2 * i, 2), 16);
	  return bytes;
	}

	// === SLH-DSA-SHAKE-256s signing keygen (synchronous but CPU-intensive) ===
	function generateSLHDSA() {
	  const { publicKey: pk, secretKey: sk } = slh_dsa_shake_256s.keygen();
	  return { pk, sk };
	}

	// === KitchenSink: ML-KEM-768 + X25519, HKDF-SHA-256 ===
	function generateKitchenSink() {
	  const { publicKey: mlkem768pk, secretKey: mlkem768sk } = ml_kem768.keygen();

	  const x25519SK = x25519.utils.randomPrivateKey();
	  const x25519PK = x25519.getPublicKey(x25519SK);

	  // KEM encapsulation
	  const { cipherText: ciphertext, sharedSecret: kemSS } = ml_kem768.encapsulate(mlkem768pk);

	  // ECDH: use a fresh ephemeral key as the peer (demo ‚Äî real use needs a recipient‚Äôs public key)
	  const ephSK = x25519.utils.randomPrivateKey();
	  const x25519SS = x25519.getSharedSecret(ephSK, x25519PK);

	  // Combine KEM + ECDH shared secrets via HKDF-SHA-256
	  const ikm = new Uint8Array([...kemSS, ...x25519SS]);
	  const info = new TextEncoder().encode(‚ÄòPQC-Hybrid-OpenPGP‚Äô);
	  const combinedSS = hkdf(sha256, ikm, new Uint8Array(0), info, 48);

	  return { mlkem768pk, mlkem768sk, x25519PK, x25519SK, combinedSS, ciphertext };
	}

	// === XWing: ML-KEM-768 + X25519 (test-vector shared secret for demo) ===
	function generateXWing() {
	  const { publicKey: mlkem768pk, secretKey: mlkem768sk } = ml_kem768.keygen();
	  const { cipherText: ciphertext, sharedSecret: combinedSS } = ml_kem768.encapsulate(mlkem768pk);
	  return {
		mlkem768pk, mlkem768sk,
		x25519PK: x25519.getPublicKey(x25519.utils.randomPrivateKey()),
		x25519SK: x25519.utils.randomPrivateKey(),
		combinedSS, ciphertext,
	  };
	}

	// === Generate Hybrid PQC Key (SLH-DSA + ML-KEM+X448 or KitchenSink/XWing) ===
	async function generatePQCKey(mode = ‚Äòx448‚Äô) {
	  const out = document.getElementById(‚Äòoutput‚Äô);
	  out.textContent = ‚ÄòGenerating‚Ä¶ SLH-DSA key gen may take 10‚Äì30 s, please wait.‚Äô;

	  // Yield to browser so the message renders before the blocking SLH-DSA call
	  await new Promise(r => setTimeout(r, 50));

	  // Step 1: SLH-DSA signing key (synchronous, CPU-intensive)
	  const slhKP = generateSLHDSA();

	  // Step 2: Hybrid KEM key
	  let kemKP;
	  if (mode === ‚Äòx448‚Äô) {
		// RFC 9580 v6 + draft: ML-KEM-1024 + X448
		const { publicKey: mlkemPK, secretKey: mlkemSK } = ml_kem1024.keygen();
		const x448SK = x448.utils.randomPrivateKey();
		const x448PK = x448.getPublicKey(x448SK);
		kemKP = { mlkem768pk: mlkemPK, mlkemSK, x448PK, x448SK };
	  } else if (mode === ‚Äòxwing‚Äô) {
		kemKP = generateXWing();
	  } else {
		kemKP = generateKitchenSink();
	  }

	  // Serialize primary (SLH-DSA) + subkey (KEM)
	  const primary = armoredOpenPGP("PUBLIC", slhKP.pk);
	  const subkey  = armoredOpenPGP("SUBKEY", kemKP.mlkem768pk);
	  const all = `${primary}\n\n${subkey}`;

	  out.textContent = all;

	  const blob = new Blob([all], { type: ‚Äòtext/plain‚Äô });
	  window.pqcBlob = blob;
	  window.pqcKeys = { slhPK: slhKP.pk, slhSK: slhKP.sk, kemKP };

	  // Auto-download
	  const a = document.createElement(‚Äòa‚Äô);
	  a.href = URL.createObjectURL(blob);
	  a.download = `pqc-key-${mode}-${Date.now()}.asc`;
	  document.body.appendChild(a);
	  a.click();
	  document.body.removeChild(a);
	}

	// Expose for inline onclick handlers
	window.generatePQCKey = generatePQCKey;
  </script>
</head>

<body>
  <div class="container">
	<h1>üîê PQC Key Lab (RFC 9580 v6 / OpenPGP draft)</h1>
	<p>Generate hybrid PQC keys: <strong>SLH-DSA-SHAKE-256s</strong> (signing) + <strong>ML-KEM+X448 / XWing / KitchenSink</strong> (encryption)</p>

	<div class="panel" id="keygen">
	  <label>Choose PQC Profile</label>
	  <select id="profileMode" onchange="this.onchange = null; alert('Selected mode: ' + this.value);">
		<option value="x448" selected>SLH-DSA + ML-KEM-1024/X448 (XWing-style, RFC 9580)</option>
		<option value="xwing">XWing (ML-KEM-768 + X25519, SHAKE256/HKDF)</option>
		<option value="kitchensink">KitchenSink (ML-KEM-768 + X25519, SHAKE256/HKDF)</option>
	  </select>

	  <div class="warn-box">
		‚ö†Ô∏è SLH-DSA signing is CPU-intensive. Key generation may take 10‚Äì30 seconds.
		<br>This is expected for hash-based signatures. Browser tab must stay active.
	  </div>

	  <label>User ID</label>
	  <input type="text" id="userId" value="PQC Test User <pqc@example.org>" />

	  <div class="btn-row">
		<button class="btn btn-primary" onclick="generatePQCKey(document.getElementById('profileMode').value)">
		  ‚ö° Generate Key
		</button>
	  </div>

	  <label>ASCII-Armored .asc Output</label>
	  <textarea id="output" placeholder="Keys will appear here..."></textarea>

	  <div class="btn-row">
		<button class="btn btn-secondary" onclick="
		  const blob = window.pqcBlob || new Blob([document.getElementById('output').value]);
		  const a = document.createElement('a');
		  a.href = URL.createObjectURL(blob);
		  a.download = 'pqc-key.asc';
		  document.body.appendChild(a); a.click(); document.body.removeChild(a);
		">‚¨á Download .asc</button>
	  </div>
	</div>

	<footer style="margin-top: 2rem; font-size: 0.9rem; color: #7f8c8d;">
	  <p>Uses <strong><a href="https://github.com/paulmillr/noble-post-quantum">noble-post-quantum</a></strong> + <strong><a href="https://github.com/paulmillr/noble-curves">noble-curves</a></strong> + <strong><a href="https://github.com/paulmillr/noble-hashes">noble-hashes</a></strong>.</p>
	  <p>Key generation uses SHA3-512 for SLH-DSA (per draft-ietf-openpgp-pqc-12)</p>
	</footer>
  </div>
</body>
</html>